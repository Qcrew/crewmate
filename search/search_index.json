{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qcrew crewmate","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install crewmate\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>from crewmate.utils import quick_wigner\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>Quickly plot Wigner functions.</p> <pre><code># import crewmate functions\nfrom crewmate.utils import quick_wigner\n# Define system dimensions\nq_dim = 2\nc_dim = 5\n# Define qubit and cavity states\ng = [1,0]\nfock1 = [0,1,0,0,0]\npsi = np.kron(g, fock1)\n# Plot Wigner of the state in the cavity\nquick_wigner(psi, [q_dim, c_dim])\n</code></pre>"},{"location":"cost_functions-reference/","title":"cost_functions","text":""},{"location":"cost_functions-reference/#crewmate.cost_functions.compute_neumann_cost_qctrl","title":"<code>compute_neumann_cost_qctrl(graph, duration, max_amplitude, drive)</code>","text":"<p>Compute Neumann boundary cost. Part of ensuring that the drive has a sufficiently small bandwidth is forcing the pulse start and end at zero. So the Neumann boundary cost is proportional to the sum of the amplidutes of the pulse in its first and last point.</p>"},{"location":"cost_functions-reference/#crewmate.cost_functions.compute_neumann_cost_qctrl--parameters","title":"Parameters","text":"qctrlcommons.data_types.Graph <p>QCTRL graph</p> int <p>pulse float [s]</p> float <p>maximum drive amplitude [rad.Hz]</p> qctrlcommons.node.node_data.Pwc <p>QCTRL drive</p>"},{"location":"cost_functions-reference/#crewmate.cost_functions.compute_neumann_cost_qctrl--returns","title":"Returns","text":"<p>float     Neumann cost</p> Source code in <code>src/crewmate/cost_functions.py</code> <pre><code>def compute_neumann_cost_qctrl(\ngraph: qctrlcommons.data_types.Graph,\nduration: float,\nmax_amplitude: float,\ndrive: qctrlcommons.node.node_data.Pwc\n) -&gt; float:\n\"\"\"Compute Neumann boundary cost. Part of ensuring that the drive has a sufficiently small bandwidth\n    is forcing the pulse start and end at zero. So the Neumann boundary cost is proportional to the sum of\n    the amplidutes of the pulse in its first and last point.\n    Parameters\n    ----------\n    graph : qctrlcommons.data_types.Graph\n        QCTRL graph\n    duration : int\n        pulse float [s]\n    max_amplitude: float\n        maximum drive amplitude [rad.Hz]\n    drive : qctrlcommons.node.node_data.Pwc\n        QCTRL drive\n    Returns\n    -------\n    float\n        Neumann cost\n    \"\"\"\nduration -= 1e-12  # Make is within the bounds of the pulse\nstart_end_times = [0, duration]\nstart_end_cavity_amp = graph.sample_pwc(drive, start_end_times)\nstart_end_cavity_amp = graph.abs(start_end_cavity_amp) ** 2\nneumann_cost = graph.sum(start_end_cavity_amp)\nneumann_cost = neumann_cost / (2 * max_amplitude ** 2)  # Normalization\nneumann_cost.name = \"Neumann boundary cost\"\nreturn neumann_cost\n</code></pre>"},{"location":"fit-reference/","title":"fit","text":""},{"location":"qctrl-reference/","title":"qctrl","text":""},{"location":"qctrl-reference/#crewmate.qctrl.apply_D_SNAP_sequence","title":"<code>apply_D_SNAP_sequence(graph, params, c_dim, psi_init)</code>","text":"<p>Apply an interleaved sequence of displacement and SNAP gates (D-SNAP-D...) to psi_init.</p>"},{"location":"qctrl-reference/#crewmate.qctrl.apply_D_SNAP_sequence--parameters","title":"Parameters","text":"qctrlcommons.data_types.Graph <p>QCTRL graph</p> np.array | list <p>sequence parameters. Use build_sequence_params to create this list.</p> int <p>dimension of the Hilber space</p> qctrlcommons.node.node_data.Tensor | np.array <p>description</p>"},{"location":"qctrl-reference/#crewmate.qctrl.apply_D_SNAP_sequence--returns","title":"Returns","text":"<p>qctrlcommons.node.node_data.Tensor     State after the application of the gates.</p> Source code in <code>src/crewmate/qctrl.py</code> <pre><code>def apply_D_SNAP_sequence(\ngraph: qctrlcommons.data_types.Graph,\nparams: Union[np.array, list],\nc_dim: int,\npsi_init: Union[qctrlcommons.node.node_data.Tensor, np.array]\n) -&gt; qctrlcommons.node.node_data.Tensor:\n\"\"\"Apply an interleaved sequence of displacement and SNAP gates (D-SNAP-D...) to psi_init.\n    Parameters\n    ----------\n    graph : qctrlcommons.data_types.Graph\n        QCTRL graph\n    params : np.array | list\n        sequence parameters. Use build_sequence_params to create this list.\n    c_dim : int\n        dimension of the Hilber space\n    psi_init : qctrlcommons.node.node_data.Tensor | np.array\n        _description_\n    Returns\n    -------\n    qctrlcommons.node.node_data.Tensor\n        State after the application of the gates.\n    \"\"\"\nif ((len(params)-1) % 2 != 0):\nraise Exception(\n\"Invalid params vector. It must hold (len(params)-1) % 2 = 0.\")\nI = np.eye(c_dim)\nstate = psi_init[:, None]\nfor i in range(len(params)):\ngate = I\nif i % 2 == 0:\ngate = displacement(graph, params[i], c_dim)\nelse:\ngate = I * graph.exp(1j*params[i])\nstate = gate @ state\nreturn state[:, 0]\n</code></pre>"},{"location":"qctrl-reference/#crewmate.qctrl.build_snap_sequence_params","title":"<code>build_snap_sequence_params(graph, c_dim, seq_length, D_var, S_var, verbose=False)</code>","text":"<p>Bundle the displacement and SNAP parameters in the format used by the apply_D_SNAP_D_sequence function.</p>"},{"location":"qctrl-reference/#crewmate.qctrl.build_snap_sequence_params--parameters","title":"Parameters","text":"qctrlcommons.data_types.Graph <p>QCTRL graph</p> int <p>dimension of the Hilbert space</p> int <p>length of the D-SNAP-D sequence (e.g. D-SNAP-D = 3, D-SNAP-D-D-SNAP-D = 6)</p> qctrlcommons.node.node_data.Tensor <p>displacement parameters</p> qctrlcommons.node.node_data.Tensor <p>SNAP parameters as a 1D flat array</p> bool <p>If true prints the gate sequence</p>"},{"location":"qctrl-reference/#crewmate.qctrl.build_snap_sequence_params--returns","title":"Returns","text":"<p>list     D_SNAP_D parameters</p> Source code in <code>src/crewmate/qctrl.py</code> <pre><code>def build_snap_sequence_params(\ngraph: qctrlcommons.data_types.Graph,\nc_dim: int,\nseq_length: int,\nD_var: qctrlcommons.node.node_data.Tensor,\nS_var: qctrlcommons.node.node_data.Tensor,\nverbose: bool = False\n) -&gt; list:\n\"\"\"Bundle the displacement and SNAP parameters in the format used by the apply_D_SNAP_D_sequence function.\n    Parameters\n    ----------\n    graph : qctrlcommons.data_types.Graph\n        QCTRL graph\n    c_dim : int\n        dimension of the Hilbert space\n    seq_length : int\n        length of the D-SNAP-D sequence (e.g. D-SNAP-D = 3, D-SNAP-D-D-SNAP-D = 6)\n    D_var : qctrlcommons.node.node_data.Tensor\n        displacement parameters\n    S_var : qctrlcommons.node.node_data.Tensor\n        SNAP parameters as a 1D flat array\n    verbose: bool\n        If true prints the gate sequence\n    Returns\n    -------\n    list\n        D_SNAP_D parameters\n    \"\"\"\nif ((seq_length-1) % 2 != 0):\nraise Exception(\nf\"Invalid sequence length: {seq_length}. It must hold (seq_length-1) % 2 = 0.\")\nS_num = int((seq_length-1)/2)\nS_dim = int(S_var.shape[0] / S_num)\nif (S_dim &gt; c_dim):\nraise Exception(\nf\"The dimension of SNAP parameters theta ({S_dim}) cannot be greater than Hilber space dimension c_dim ({c_dim})\")\nS_fill = np.zeros(c_dim-S_dim)\nparams = []\ni, d, s = 0, 0, 0\nfor i in range(seq_length):\nif i % 2 == 0:\nif verbose:\nprint(f\"{i}\\tD-{d}\")\nparams.append(D_var[d])\nd += 1\nelse:\nidx = S_dim*s\nparams.append(graph.concatenate([S_var[idx:idx+S_dim], S_fill], 0))\nif verbose:\nprint(f\"{i}\\tS-{s}  {S_var[idx:idx+S_dim].shape}\")\ns += 1\nreturn params\n</code></pre>"},{"location":"qctrl-reference/#crewmate.qctrl.define_bandwidth_drive","title":"<code>define_bandwidth_drive(graph, variable_count, duration, maximum, cutoff_frequency, segment_count=-1)</code>","text":"<p>Define an optimizable complex pwc signal limited by the <code>cutoff_frequency</code>. The pulse is optimized using a number of variables <code>variable_count</code>. Then the pulse is resampled in <code>segment_count</code> points and convoluted with a sinc kernel, before the cost function is calculated.</p>"},{"location":"qctrl-reference/#crewmate.qctrl.define_bandwidth_drive--parameters","title":"Parameters","text":"qctrlcommons.data_types.Graph <p>QCTRL graph</p> int <p>Number of optimizable variables</p> int <p>Pulse duration [s]</p> float <p>Drive maximum</p> float <p>Maximum frequency allowed by the drive</p> int, optioinal <p>Number of pwc segments after sampling. By default = -1, meaning the pulse will be sampled every nanosecond (duration * 1e9).</p>"},{"location":"qctrl-reference/#crewmate.qctrl.define_bandwidth_drive--returns","title":"Returns","text":"<p>qctrlcommons.node.node_data.Pwc     QCTRL complex optimizable pwc signal</p> Source code in <code>src/crewmate/qctrl.py</code> <pre><code>def define_bandwidth_drive(\ngraph: qctrlcommons.data_types.Graph,\nvariable_count: int,\nduration: float,\nmaximum: float,\ncutoff_frequency: float,\nsegment_count: int = -1\n) -&gt; qctrlcommons.node.node_data.Pwc:\n\"\"\"Define an optimizable complex pwc signal limited by the `cutoff_frequency`.\n    The pulse is optimized using a number of variables `variable_count`.\n    Then the pulse is resampled in `segment_count` points and convoluted with a sinc kernel,\n    before the cost function is calculated.\n    Parameters\n    ----------\n    graph : qctrlcommons.data_types.Graph\n        QCTRL graph\n    variable_count : int\n        Number of optimizable variables\n    duration : int\n        Pulse duration [s]\n    maximum : float\n        Drive maximum\n    cutoff_frequency : float\n        Maximum frequency allowed by the drive\n    segment_count : int, optioinal\n        Number of pwc segments after sampling.\n        By default = -1, meaning the pulse will be sampled every nanosecond (duration * 1e9).\n    Returns\n    -------\n    qctrlcommons.node.node_data.Pwc\n        QCTRL complex optimizable pwc signal\n    \"\"\"\nif segment_count == -1:\nint(duration*1e9)\n# Define raw drive\nraw_drive = graph.utils.complex_optimizable_pwc_signal(\nsegment_count=variable_count,\nduration=duration,\nmaximum=maximum,\n)\n# Apply sinc cut to raw drives\ndrive = graph.utils.filter_and_resample_pwc(\npwc=raw_drive,\ncutoff_frequency=cutoff_frequency,\nsegment_count=segment_count\n)\nreturn drive\n</code></pre>"},{"location":"qctrl-reference/#crewmate.qctrl.define_ladder_operators","title":"<code>define_ladder_operators(graph, c_dim=1, q_dim=1)</code>","text":"<p>Generate the ladder operators for the oscillator and the qubit</p>"},{"location":"qctrl-reference/#crewmate.qctrl.define_ladder_operators--parameters","title":"Parameters","text":"qctrl.graphs.Graph <p>QCTR graph</p> int <p>Oscillator Hilbert space dimension</p> int <p>Qubit Hilbert space dimension</p>"},{"location":"qctrl-reference/#crewmate.qctrl.define_ladder_operators--returns","title":"Returns","text":"<p>{ [a, ad, q, qd]: qctrlcommons.node.node_data.Tensor }     SimpleNamespace containing the ladder operators</p>"},{"location":"qctrl-reference/#crewmate.qctrl.define_ladder_operators--examples","title":"Examples","text":"<p>Use ladder operators to compute the number operator</p> <p>ladder = define_ladder_operators(graph, 3, 2) n = ladder.ad @ ladder.a</p> Source code in <code>src/crewmate/qctrl.py</code> <pre><code>def define_ladder_operators(graph: qctrlcommons.data_types.Graph, c_dim: int = 1, q_dim: int = 1) -&gt; SimpleNamespace:\n\"\"\"Generate the ladder operators for the oscillator and the qubit\n    Parameters\n    ----------\n    graph : qctrl.graphs.Graph\n        QCTR graph\n    c_dim : int\n        Oscillator Hilbert space dimension\n    q_dim : int\n        Qubit Hilbert space dimension\n    Returns\n    -------\n    { [a, ad, q, qd]: qctrlcommons.node.node_data.Tensor }\n        SimpleNamespace containing the ladder operators\n    Examples\n    --------\n    Use ladder operators to compute the number operator\n    &gt;&gt;&gt; ladder = define_ladder_operators(graph, 3, 2)\n    &gt;&gt;&gt; n = ladder.ad @ ladder.a\n    \"\"\"\nladder_operators = {\n'a': np.eye(1),\n'ad': np.eye(1),\n'q': np.eye(1),\n'qd': np.eye(1)\n}\n# Oscillator\nif (c_dim &gt; 1):\na = graph.kronecker_product_list([\ngraph.annihilation_operator(c_dim),\nnp.eye(q_dim),\n])\nad = graph.kronecker_product_list([\ngraph.creation_operator(c_dim),\nnp.eye(q_dim),\n])\nladder_operators['a'] = a\nladder_operators['ad'] = ad\n# Qubit\nif (q_dim &gt; 1):\nq = graph.kronecker_product_list([\nnp.eye(c_dim),\ngraph.annihilation_operator(q_dim),\n])\nqd = graph.kronecker_product_list([\nnp.eye(c_dim),\ngraph.creation_operator(q_dim),\n])\nladder_operators['q'] = q\nladder_operators['qd'] = qd\nreturn SimpleNamespace(**ladder_operators)\n</code></pre>"},{"location":"qctrl-reference/#crewmate.qctrl.displacement","title":"<code>displacement(graph, alpha, c_dim)</code>","text":"<p>Generate the matrix associated with the displacement operator D(alpha)</p>"},{"location":"qctrl-reference/#crewmate.qctrl.displacement--parameters","title":"Parameters","text":"qctrlcommons.data_types.Graph <p>QCTRL graph</p> float <p>displacement parameter</p> int <p>dimension of the Hilber space</p>"},{"location":"qctrl-reference/#crewmate.qctrl.displacement--returns","title":"Returns","text":"<p>qctrlcommons.node.node_data.Tensor     QCTRL tensor containing the operator</p> Source code in <code>src/crewmate/qctrl.py</code> <pre><code>def displacement(graph: qctrlcommons.data_types.Graph, alpha: float, c_dim: int) -&gt; qctrlcommons.node.node_data.Tensor:\n\"\"\"Generate the matrix associated with the displacement operator D(alpha)\n    Parameters\n    ----------\n    graph : qctrlcommons.data_types.Graph\n        QCTRL graph\n    alpha : float\n        displacement parameter\n    c_dim : int\n        dimension of the Hilber space\n    Returns\n    -------\n    qctrlcommons.node.node_data.Tensor\n        QCTRL tensor containing the operator\n    \"\"\"\na = graph.annihilation_operator(c_dim)\nad = graph.creation_operator(c_dim)\nD = graph.multiply(1, np.eye(c_dim))\nterm = np.eye(c_dim)\nfor i in range(1, 30):\nterm = -graph.sum(graph.outer_product(1/i *\n(alpha * ad - graph.conjugate(alpha) * a), term), 0)\nD = graph.add(D, term)\nreturn D\n</code></pre>"},{"location":"qctrl-reference/#crewmate.qctrl.sampleNsave","title":"<code>sampleNsave(drives, gate_duration, file_name)</code>","text":"<p>Sample drives to 1 ns and save them in a csv file.</p>"},{"location":"qctrl-reference/#crewmate.qctrl.sampleNsave--parameters","title":"Parameters","text":"np.array <p>Array of drives. Each drive must be an array of drive amplitudes.</p> float <p>gate duration in seconds.</p> str <p>filename, will save to file_name.csv</p> Source code in <code>src/crewmate/qctrl.py</code> <pre><code>def sampleNsave(drives: np.array, gate_duration: float, file_name: str):\n\"\"\"Sample drives to 1 ns and save them in a csv file.\n    Parameters\n    ----------\n    drives : np.array\n        Array of drives. Each drive must be an array of drive amplitudes.\n    gate_duration : float\n        gate duration in seconds.\n    file_name : str\n        filename, will save to file_name.csv\n    \"\"\"\ndrives = np.array(drives)\nif (drives.ndim != 2):\nraise \"Array must be 2D, if you only have one drive use [drive]\"\ngraph = qctrl.create_graph()\nsample_times = np.linspace(0, gate_duration, int(gate_duration * 1e9))\n# Make sure the last datapoint is within boundaries\nsample_times[-1] -= 1e-12\nfor i in range(len(drives)):\ndrive_len = len(drives[i])\n# Sample drive to 1 ns intervals\npwc = graph.pwc(\ngate_duration/drive_len * np.ones(drive_len),\ndrives[i]\n)\ngraph.sample_pwc(pwc, sample_times, name=f\"d{i}\")\nres = qctrl.functions.calculate_graph(\ngraph=graph,\noutput_node_names=[f\"d{i}\" for i in range(len(drives))]\n)\nsampled_drives = []\nfor i in range(len(drives)):\nsampled_drives.append(res.output[f\"d{i}\"][\"value\"])\nsampled_drives = np.array(sampled_drives)\nnp.savetxt(f\"{file_name}.csv\", sampled_drives, delimiter=\",\")\n</code></pre>"},{"location":"utils-reference/","title":"utils","text":""},{"location":"utils-reference/#crewmate.utils.cd","title":"<code>cd(alphas, c_dim)</code>","text":"<p>Get the conditional displacement matrix in a qubit-cavity system. Qubit space dimension is assumed to be 2.</p>"},{"location":"utils-reference/#crewmate.utils.cd--parameters","title":"Parameters","text":"np.array <p>Array containing the values of the displacements (e.g. [-1,1] -&gt; if qubit in |g&gt; displace by -1, if qubit in |e&gt; displace by 1).</p> int <p>Dimension of the cavity Hilbert space.</p>"},{"location":"utils-reference/#crewmate.utils.cd--returns","title":"Returns","text":"<p>np.array     Conditional displacement matrix.</p>"},{"location":"utils-reference/#crewmate.utils.cd--examples","title":"Examples","text":"<p>Create a conditional displacement gate for a qubit-cavity system of dimension 2 x 15.</p> <p>cd([-1,1], 15)</p> Source code in <code>src/crewmate/utils.py</code> <pre><code>def cd(alphas: np.array, c_dim: int) -&gt; np.array:\n\"\"\"Get the conditional displacement matrix in a qubit-cavity system.\n    Qubit space dimension is assumed to be 2.\n    Parameters\n    ----------\n    alphas : np.array\n        Array containing the values of the displacements\n        (e.g. [-1,1] -&gt; if qubit in |g&gt; displace by -1, if qubit in |e&gt; displace by 1).\n    c_dim : int\n        Dimension of the cavity Hilbert space.\n    Returns\n    -------\n    np.array\n        Conditional displacement matrix.\n    Examples\n    --------\n    Create a conditional displacement gate for a qubit-cavity system of dimension 2 x 15.\n    &gt;&gt;&gt; cd([-1,1], 15)\n    \"\"\"\nD_gates = [qt.displace(c_dim, alpha) for alpha in alphas]\nreturn block_diag(*D_gates)\n</code></pre>"},{"location":"utils-reference/#crewmate.utils.ecd","title":"<code>ecd(alpha, chi, wait_time, c_dim)</code>","text":"<p>Get ECD gate matrix in a qubit-cavity system, assuming the qubit space dimension = 2. ECD parameter beta = 2j * alpha * sin(chi * wait_time/2)</p>"},{"location":"utils-reference/#crewmate.utils.ecd--parameters","title":"Parameters","text":"float <p>alpha of the first displacement gate ECD sequence.</p> float <p>Dispersive coupling strength in rad*Hz.</p> float <p>Time between the first 2 displacement gates in the ECD sequence in nanoseconds.</p> int <p>Dimension of the cavity Hilbert space.</p>"},{"location":"utils-reference/#crewmate.utils.ecd--returns","title":"Returns","text":"<p>np.array     ECD gate matrix.</p> Source code in <code>src/crewmate/utils.py</code> <pre><code>def ecd(alpha: float, chi: float, wait_time: float, c_dim: int) -&gt; np.array:\n\"\"\"Get ECD gate matrix in a qubit-cavity system,\n    assuming the qubit space dimension = 2.\n    ECD parameter beta = 2j * alpha * sin(chi * wait_time/2)\n    Parameters\n    ----------\n    alpha : float\n        alpha of the first displacement gate ECD sequence.\n    chi : float\n        Dispersive coupling strength in rad*Hz.\n    wait_time : float\n        Time between the first 2 displacement gates in the ECD sequence in nanoseconds.\n    c_dim : int\n        Dimension of the cavity Hilbert space.\n    Returns\n    -------\n    np.array\n        ECD gate matrix.\n    \"\"\"\nbeta = 2j * alpha * np.sin(chi * wait_time/2)\nD_gates = [qt.displace(c_dim, a) for a in [-beta, beta]]\nreturn np.flip(block_diag(*D_gates), 0)\n</code></pre>"},{"location":"utils-reference/#crewmate.utils.find_highest_populated_state","title":"<code>find_highest_populated_state(state, tolerance=1e-06)</code>","text":"<p>Find the highest Fock state that is populated for more than the specified tolerance.</p>"},{"location":"utils-reference/#crewmate.utils.find_highest_populated_state--parameters","title":"Parameters","text":"np.array <p>Quantum state in the Fock basis.</p> float, optional <p>Population tolerance, by default 1e-6</p>"},{"location":"utils-reference/#crewmate.utils.find_highest_populated_state--returns","title":"Returns","text":"<p>int     Number of the highest populated-enough state.</p>"},{"location":"utils-reference/#crewmate.utils.find_highest_populated_state--raises","title":"Raises","text":"<p>Exception     If couldn't find a populated-enough state.</p>"},{"location":"utils-reference/#crewmate.utils.find_highest_populated_state--examples","title":"Examples","text":"<p>In this case state |1&gt; is the highest populated state, considering the default tolerance of 1e-6.</p> <p>find_highest_populated_state([0.99, 0.01, 0]) 1</p> <p>Now state |0&gt; is the highest populated state, considering a tolerance of 0.1.</p> <p>find_highest_populated_state([0.99, 0.01, 0], tolerance=0.1) 0</p> Source code in <code>src/crewmate/utils.py</code> <pre><code>def find_highest_populated_state(state: np.array, tolerance: float = 1e-6) -&gt; int:\n\"\"\"Find the highest Fock state that is populated for more than the specified tolerance.\n    Parameters\n    ----------\n    state : np.array\n        Quantum state in the Fock basis.\n    tolerance : float, optional\n        Population tolerance, by default 1e-6\n    Returns\n    -------\n    int\n        Number of the highest populated-enough state.\n    Raises\n    ------\n    Exception\n        If couldn't find a populated-enough state.\n    Examples\n    --------\n    In this case state |1&gt; is the highest populated state, considering the default tolerance of 1e-6.\n    &gt;&gt;&gt; find_highest_populated_state([0.99, 0.01, 0])\n    1\n    Now state |0&gt; is the highest populated state, considering a tolerance of 0.1.\n    &gt;&gt;&gt; find_highest_populated_state([0.99, 0.01, 0], tolerance=0.1)\n    0\n    \"\"\"\n# Highest occupied state above tolerance\nhighest = -1\nstate_abs = np.abs(state) ** 2\nfor n in range(len(state)-1, -1, -1):\nif state_abs[n] &gt; tolerance:\nhighest = n\nbreak\nif (highest == -1 or highest == len(state)-1 and state_abs[highest] &gt; tolerance):\nmessage = (\"Couldn't find a Fock state below the target population tolerance.\\n\" +\n\"Consider increasing the size of the Hilber space.\\n\")\nif (highest &gt; -1):\nmessage += (\nf\"Target population tolerance: {tolerance}\\n\" +\nf\"Found: {state_abs[highest]} for Fock state |{highest}&gt;\"\n)\nraise Exception(message)\nelif (highest == len(state)-1):\nprint(f\"WARNING: The highest populated state coincides with the system's dimension ({highest}).\\n\" +\n\"There could be higher occupied states that aren't being accounted for.\")\nreturn highest\n</code></pre>"},{"location":"utils-reference/#crewmate.utils.quick_wigner","title":"<code>quick_wigner(psi, dims, title='Wigner', trace_idx=1, x_lim=[-3, 3], y_lim=[-3, 3], pixel_count=200, contour_levels=100)</code>","text":"<p>Plot the Wigner function of psi. By default the system is assumed to be qubit-cavity.</p>"},{"location":"utils-reference/#crewmate.utils.quick_wigner--parameters","title":"Parameters","text":"np.array <p>State to plot.</p> np.arrayorlistorint <p>Dimensions of components of the system. (e.g. 2 dimensional qubit and 15 dimensional cavity -&gt; dims = [2,15])</p> str, optional <p>Plot title, by default \"Wigner\"</p> int, optional <p>The index of the system element that you want to plot, by default 1. (e.g. consider a qubit and a cavity with dimensions [2,15], if you want to plot the cavity use trance_idx=1)</p> np.arrayorlist, optional <p>Limit on the x axis, by default [-3, 3]</p> np.arrayorlist, optional <p>Limit on the y axis, by default [-3, 3]</p> int, optional <p>Number of pixels, by default 200</p> int, optional <p>Number of contour levels, by default 100</p>"},{"location":"utils-reference/#crewmate.utils.quick_wigner--examples","title":"Examples","text":"<p>Plot the Wigner function of the cavity. psi = |g&gt;|0&gt;, considering qubit dimension = 2 and cavity dimension = 3.</p> <p>quick_wigner([1,0,0,0,0,0], [2,3])</p> <p>Plot the Wigner function of the qubit. psi = |g&gt;|0&gt;, considering qubit dimension = 2 and cavity dimension = 3.</p> <p>quick_wigner([1,0,0,0,0,0], [2,3], trace_idx=0)</p> Source code in <code>src/crewmate/utils.py</code> <pre><code>def quick_wigner(\npsi: np.array,\ndims: Union[int, np.array, list],\ntitle: str = \"Wigner\",\ntrace_idx: int = 1,\nx_lim: Union[np.array, list] = [-3, 3],\ny_lim: Union[np.array, list] = [-3, 3],\npixel_count: int = 200,\ncontour_levels: int = 100\n) -&gt; None:\n\"\"\"Plot the Wigner function of psi. By default the system is assumed to be qubit-cavity.\n    Parameters\n    ----------\n    psi : np.array\n        State to plot.\n    dims : np.arrayorlistorint\n        Dimensions of components of the system.\n        (e.g. 2 dimensional qubit and 15 dimensional cavity -&gt; dims = [2,15])\n    title : str, optional\n        Plot title, by default \"Wigner\"\n    trace_idx : int, optional\n        The index of the system element that you want to plot, by default 1.\n        (e.g. consider a qubit and a cavity with dimensions [2,15],\n        if you want to plot the cavity use trance_idx=1)\n    x_lim : np.arrayorlist, optional\n        Limit on the x axis, by default [-3, 3]\n    y_lim : np.arrayorlist, optional\n        Limit on the y axis, by default [-3, 3]\n    pixel_count : int, optional\n        Number of pixels, by default 200\n    contour_levels : int, optional\n        Number of contour levels, by default 100\n    Examples\n    --------\n    Plot the Wigner function of the cavity.\n    psi = |g&gt;|0&gt;, considering qubit dimension = 2 and cavity dimension = 3.\n    &gt;&gt;&gt; quick_wigner([1,0,0,0,0,0], [2,3])\n    Plot the Wigner function of the qubit.\n    psi = |g&gt;|0&gt;, considering qubit dimension = 2 and cavity dimension = 3.\n    &gt;&gt;&gt; quick_wigner([1,0,0,0,0,0], [2,3], trace_idx=0)\n    \"\"\"\nif len(x_lim) != 2:\nraise print(f\"Length of x_lim must be 2, but got {len(x_lim)}.\")\nif len(y_lim) != 2:\nraise print(f\"Length of y_lim must be 2, but got {len(y_lim)}.\")\nif isinstance(dims, int):\ndims = [dims]\ntrace_idx = 0\nx = np.linspace(x_lim[0], x_lim[1], pixel_count)\ny = np.linspace(y_lim[0], y_lim[1], pixel_count)\nstate = qt.Qobj(np.array(psi), dims=[dims, [1, 1]])\nstate_wigner = qt.wigner(state.ptrace(trace_idx), x, y)\n# Plot\nfig = plt.figure(figsize=(5, 4), dpi=100)\nstate_max = np.max(np.abs(np.array(state_wigner)))\ncolor_norm = colors.TwoSlopeNorm(\nvmin=-state_max, vcenter=0., vmax=state_max)\ncontour = plt.contourf(\nx, y, state_wigner, contour_levels, cmap=\"bwr_r\", norm=color_norm)\nfig.colorbar(contour)\nplt.title(title)\nplt.show()\n</code></pre>"},{"location":"utils-reference/#crewmate.utils.read_drives_csv","title":"<code>read_drives_csv(file_name)</code>","text":"<p>Read drives from csv file.</p>"},{"location":"utils-reference/#crewmate.utils.read_drives_csv--parameters","title":"Parameters","text":"str <p>File name.</p>"},{"location":"utils-reference/#crewmate.utils.read_drives_csv--returns","title":"Returns","text":"<p>np.array     Drive list.</p> Source code in <code>src/crewmate/utils.py</code> <pre><code>def read_drives_csv(file_name: str) -&gt; list[np.array]:\n\"\"\"Read drives from csv file.\n    Parameters\n    ----------\n    file_name : str\n        File name.\n    Returns\n    -------\n    np.array\n        Drive list.\n    \"\"\"\nif file_name.endswith('.csv'):\nfile_name = file_name[0:-4]\nreturn np.genfromtxt(f\"{file_name}.csv\", dtype=\"complex\", delimiter=\",\")\n</code></pre>"},{"location":"utils-reference/#crewmate.utils.read_object","title":"<code>read_object(file_name)</code>","text":"<p>Read python object from a file</p>"},{"location":"utils-reference/#crewmate.utils.read_object--parameters","title":"Parameters","text":"str <p>File name, including path if needed.</p>"},{"location":"utils-reference/#crewmate.utils.read_object--returns","title":"Returns","text":"<p>any     Object</p> Source code in <code>src/crewmate/utils.py</code> <pre><code>def read_object(file_name: str):\n\"\"\"Read python object from a file\n    Parameters\n    ----------\n    file_name : str\n        File name, including path if needed.\n    Returns\n    -------\n    any\n        Object\n    \"\"\"\nwith open(f'{file_name}', 'rb') as inp:\nreturn pickle.load(inp)\n</code></pre>"},{"location":"utils-reference/#crewmate.utils.save_drives_csv","title":"<code>save_drives_csv(drives, file_name)</code>","text":"<p>Save drives as complex numbers in a csv file.</p>"},{"location":"utils-reference/#crewmate.utils.save_drives_csv--parameters","title":"Parameters","text":"list <p>A list containing the drives. Each drive must be a np.array. IMPORTANT: if you want to save only one drive specify it as [drive]</p> str <p>File name.</p> Source code in <code>src/crewmate/utils.py</code> <pre><code>def save_drives_csv(drives: list[np.array], file_name: str) -&gt; None:\n\"\"\"Save drives as complex numbers in a csv file.\n    Parameters\n    ----------\n    drives : list\n        A list containing the drives. Each drive must be a np.array.\n        IMPORTANT: if you want to save only one drive specify it as [drive]\n    file_name : str\n        File name.\n    \"\"\"\nif len(drives) &gt; 5:\nprint(\"WARNING: you are trying to save more than 5 drives\" +\n\"If you are trying to save just one drive you should specify it as [drive]\")\nif file_name.endswith('.csv'):\nfile_name = file_name[0:-4]\nnp.savetxt(f\"{file_name}.csv\", drives, delimiter=\",\")\n</code></pre>"},{"location":"utils-reference/#crewmate.utils.save_object","title":"<code>save_object(obj, file_name)</code>","text":"<p>Save a python object to a file.</p>"},{"location":"utils-reference/#crewmate.utils.save_object--parameters","title":"Parameters","text":"any <p>Object to save.</p> str <p>File name, including path if needed.</p> Source code in <code>src/crewmate/utils.py</code> <pre><code>def save_object(obj, file_name: str):\n\"\"\"Save a python object to a file.\n    Parameters\n    ----------\n    obj : any\n        Object to save.\n    file_name : str\n        File name, including path if needed.\n    \"\"\"\nwith open(f'{file_name}', 'wb') as outp:\npickle.dump(obj, outp, pickle.HIGHEST_PROTOCOL)\n</code></pre>"},{"location":"tutorials/wigner/","title":"Wigner plot","text":"<p>In this tutorial we'll go through how to use the <code>quick_wigner</code> utility function to plot great Wigner functions in just one line of code.</p>"},{"location":"tutorials/wigner/#import-necessary-libraries","title":"Import necessary libraries","text":"<p>For the following examples we'll just use <code>numpy</code> and the <code>quick_wigner</code> function from <code>crewmate</code>.</p> <pre><code>import numpy as np\nfrom crewmate.utils import quick_wigner\n</code></pre>"},{"location":"tutorials/wigner/#simple-plot","title":"Simple plot","text":"<p>As the name suggests, <code>quick_wigner</code> is designed to let users plot a good Wigner function, without going through the hassle of writing a nice plot function. We'll see how it can be used in different cases:</p>"},{"location":"tutorials/wigner/#qubit-cavity-system","title":"Qubit-cavity system","text":"<p>Consider a 3-level qubit and a 20-dimensional cavity. Now assume the qubit is the ground state \\(|g\\rangle\\) and the cavity is in \\(|2\\rangle\\).</p> <pre><code># Define qubit and cavity dimensions\nq_dim = 3\nc_dim = 20\n# Define qubit state\ng = np.zeros(q_dim)\ng[0] = 1\n# Define cavity state\nfock2 = np.zeros(c_dim)\nfock2[2] = 1\n# System's state\npsi = np.kron(g, fock2)\n</code></pre> <p>Given psi we can easily plot the Wigner function of the cavity by simply calling the <code>quick_wigner</code> function and specifying the dimension of the 2 sub-spaces we are considering (3d qubit and 20d cavity).</p> <pre><code>quick_wigner(psi, [q_dim, c_dim])\n</code></pre> <p> </p> Wigner plot of the cavity"},{"location":"tutorials/wigner/#cavity-qubit-system","title":"Cavity-qubit system","text":"<p>Consider the same system as the example above, except this time the tensor product is inverted: instead of having a qubit-cavity system we have a cavity-qubit system.</p> <pre><code># Define qubit and cavity dimensions\nq_dim = 3\nc_dim = 20\n# Define qubit state\ng = np.zeros(q_dim)\ng[0] = 1\n# Define cavity state\nfock2 = np.zeros(c_dim)\nfock2[2] = 1\n# System's state\npsi = np.kron(fock2, g)\n</code></pre> <p>By default <code>quick_wigner</code> will trace the second sub-system. In the example before the cavity was the second sub-system, so we didn't have to specify anything manually. In this case we need to let the function know that we want the Wigner function of the first sub-system by setting <code>trace_idx = 0</code>.</p> <pre><code>quick_wigner(psi, [c_dim, q_dim], trace_idx=0)\n</code></pre>"},{"location":"tutorials/wigner/#single-cavity","title":"Single cavity","text":"<pre><code>quick_wigner(fock2, c_dim)\n</code></pre>"},{"location":"tutorials/wigner/#complex-systems","title":"Complex systems","text":"<p><code>quick_wigner</code> can be used to plot any sub-system, even in more complex systems, like a 1 qubit 2 cavities setup. The idea is similar to the cavity-qubit case, we just need to specify the correct <code>trace_idx</code>. In the example below we'll consider a system in which the qubit is in \\(|g\\rangle\\), cavity1 is in \\(|1\\rangle\\), and cavity2 is in \\(|2\\rangle\\).</p> <pre><code># Define qubit and cavity dimensions\nq_dim = 3\nc_dim = 20\n# Define qubit state\ng = np.zeros(q_dim)\ng[0] = 1\n# Define cavity1 state\ncavity_1 = np.zeros(c_dim)\ncavity_1[1] = 1\n# Define cavity2 state\ncavity_2 = np.zeros(c_dim)\ncavity_2[2] = 1\n# System's state\npsi = np.kron(g, cavity_1)\npsi = np.kron (psi, cavity_2)\n</code></pre> <p>For a qubit-cavity1-cavity2 system the trace indices are 0 for the qubit, 1 for cavity1, and 2 for cavity2. <pre><code># Plot cavity 1\nquick_wigner(psi, [q_dim, c_dim, c_dim], trace_idx=1, title=\"Cavity 1\")\n# Plot cavity 2\nquick_wigner(psi, [q_dim, c_dim, c_dim], trace_idx=2, title=\"Cavity 2\")\n</code></pre></p> <p></p>"}]}